// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: heuristic/heuristic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// sensory.api.heuristic

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Precision of heuristic aggregations
public enum Sensory_Api_Heuristic_HeuristicAggregatePrecision: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case minute // = 0
  case hour // = 1
  case day // = 2
  case week // = 3
  case month // = 4
  case quarter // = 5
  case year // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .minute
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .minute
    case 1: self = .hour
    case 2: self = .day
    case 3: self = .week
    case 4: self = .month
    case 5: self = .quarter
    case 6: self = .year
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .minute: return 0
    case .hour: return 1
    case .day: return 2
    case .week: return 3
    case .month: return 4
    case .quarter: return 5
    case .year: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Heuristic_HeuristicAggregatePrecision: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Heuristic_HeuristicAggregatePrecision] = [
    .minute,
    .hour,
    .day,
    .week,
    .month,
    .quarter,
    .year,
  ]
}

#endif  // swift(>=4.2)

/// A request for a summary of usage given the inputs
public struct Sensory_Api_Heuristic_UsageSummaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional tenantId which must be a UUID. If this id is omitted, the summary will be across all tenants.
  public var tenantID: String = String()

  /// Optional filter all data before the specificed timestamp
  public var before: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _before ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_before = newValue}
  }
  /// Returns true if `before` has been explicitly set.
  public var hasBefore: Bool {return self._before != nil}
  /// Clears the value of `before`. Subsequent reads from it will return its default value.
  public mutating func clearBefore() {self._before = nil}

  /// Optional filter all data after the specificed timestamp
  public var after: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _after ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_after = newValue}
  }
  /// Returns true if `after` has been explicitly set.
  public var hasAfter: Bool {return self._after != nil}
  /// Clears the value of `after`. Subsequent reads from it will return its default value.
  public mutating func clearAfter() {self._after = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _before: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _after: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A request for historical usage bucketed by the precision parameter
public struct Sensory_Api_Heuristic_UsageHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional tenantId which must be a UUID. If this id is omitted, the history will be across all tenants.
  public var tenantID: String = String()

  /// Optional filter all data before the specificed timestamp
  public var before: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _before ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_before = newValue}
  }
  /// Returns true if `before` has been explicitly set.
  public var hasBefore: Bool {return self._before != nil}
  /// Clears the value of `before`. Subsequent reads from it will return its default value.
  public mutating func clearBefore() {self._before = nil}

  /// Optional filter all data after the specificed timestamp
  public var after: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _after ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_after = newValue}
  }
  /// Returns true if `after` has been explicitly set.
  public var hasAfter: Bool {return self._after != nil}
  /// Clears the value of `after`. Subsequent reads from it will return its default value.
  public mutating func clearAfter() {self._after = nil}

  /// Precision of the time buckets for usage aggregation
  public var precision: Sensory_Api_Heuristic_HeuristicAggregatePrecision = .minute

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _before: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _after: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A bucketed reponse from a  UsageHistoryRequest
public struct Sensory_Api_Heuristic_UsageHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bucketed aggregations of usage history
  public var buckets: [Sensory_Api_Heuristic_UsageHistoryBucket] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An aggregate bucket of usage history
public struct Sensory_Api_Heuristic_UsageHistoryBucket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Sensory_Api_Common_UsageEventType = .authentication

  public var count: Int64 = 0

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A summary of usage data
public struct Sensory_Api_Heuristic_UsageSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tenantCount: Int64 = 0

  public var deviceCount: Int64 = 0

  public var userCount: Int64 = 0

  public var serverCount: Int64 = 0

  public var authenticationCount: Int64 = 0

  public var recognitionCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sensory.api.heuristic"

extension Sensory_Api_Heuristic_HeuristicAggregatePrecision: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MINUTE"),
    1: .same(proto: "HOUR"),
    2: .same(proto: "DAY"),
    3: .same(proto: "WEEK"),
    4: .same(proto: "MONTH"),
    5: .same(proto: "QUARTER"),
    6: .same(proto: "YEAR"),
  ]
}

extension Sensory_Api_Heuristic_UsageSummaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsageSummaryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tenantId"),
    2: .same(proto: "before"),
    3: .same(proto: "after"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._before) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._after) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tenantID.isEmpty {
      try visitor.visitSingularStringField(value: self.tenantID, fieldNumber: 1)
    }
    if let v = self._before {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._after {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Heuristic_UsageSummaryRequest, rhs: Sensory_Api_Heuristic_UsageSummaryRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs._before != rhs._before {return false}
    if lhs._after != rhs._after {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Heuristic_UsageHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsageHistoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tenantId"),
    2: .same(proto: "before"),
    3: .same(proto: "after"),
    4: .same(proto: "precision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tenantID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._before) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._after) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.precision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tenantID.isEmpty {
      try visitor.visitSingularStringField(value: self.tenantID, fieldNumber: 1)
    }
    if let v = self._before {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._after {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.precision != .minute {
      try visitor.visitSingularEnumField(value: self.precision, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Heuristic_UsageHistoryRequest, rhs: Sensory_Api_Heuristic_UsageHistoryRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs._before != rhs._before {return false}
    if lhs._after != rhs._after {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Heuristic_UsageHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsageHistoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buckets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Heuristic_UsageHistoryResponse, rhs: Sensory_Api_Heuristic_UsageHistoryResponse) -> Bool {
    if lhs.buckets != rhs.buckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Heuristic_UsageHistoryBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsageHistoryBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "Count"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .authentication {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Heuristic_UsageHistoryBucket, rhs: Sensory_Api_Heuristic_UsageHistoryBucket) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.count != rhs.count {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Heuristic_UsageSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsageSummaryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TenantCount"),
    2: .same(proto: "DeviceCount"),
    3: .same(proto: "UserCount"),
    4: .same(proto: "ServerCount"),
    5: .same(proto: "AuthenticationCount"),
    6: .same(proto: "RecognitionCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.tenantCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.deviceCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.serverCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.authenticationCount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.recognitionCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tenantCount != 0 {
      try visitor.visitSingularInt64Field(value: self.tenantCount, fieldNumber: 1)
    }
    if self.deviceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.deviceCount, fieldNumber: 2)
    }
    if self.userCount != 0 {
      try visitor.visitSingularInt64Field(value: self.userCount, fieldNumber: 3)
    }
    if self.serverCount != 0 {
      try visitor.visitSingularInt64Field(value: self.serverCount, fieldNumber: 4)
    }
    if self.authenticationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.authenticationCount, fieldNumber: 5)
    }
    if self.recognitionCount != 0 {
      try visitor.visitSingularInt64Field(value: self.recognitionCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Heuristic_UsageSummaryResponse, rhs: Sensory_Api_Heuristic_UsageSummaryResponse) -> Bool {
    if lhs.tenantCount != rhs.tenantCount {return false}
    if lhs.deviceCount != rhs.deviceCount {return false}
    if lhs.userCount != rhs.userCount {return false}
    if lhs.serverCount != rhs.serverCount {return false}
    if lhs.authenticationCount != rhs.authenticationCount {return false}
    if lhs.recognitionCount != rhs.recognitionCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
