// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// sensory.api.common

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Generic NULL value
public enum Sensory_Api_Common_Void: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case value // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .value
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .value
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .value: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_Void: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_Void] = [
    .value,
  ]
}

#endif  // swift(>=4.2)

/// A type of key supported by the API
/// Note: if you change this enum, ensure to update schema.prisma KeyType
public enum Sensory_Api_Common_KeyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// General Public key - kept for backwards compatability
  case publicKey // = 0

  /// ED25519 Public key used for asymmetric cryptographic operations
  case publicKeyEd25519 // = 1

  /// Shared secret string
  case sharedSecret // = 3

  /// AES-256 32 byte string
  case aes256 // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .publicKey
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .publicKey
    case 1: self = .publicKeyEd25519
    case 3: self = .sharedSecret
    case 4: self = .aes256
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .publicKey: return 0
    case .publicKeyEd25519: return 1
    case .sharedSecret: return 3
    case .aes256: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_KeyType] = [
    .publicKey,
    .publicKeyEd25519,
    .sharedSecret,
    .aes256,
  ]
}

#endif  // swift(>=4.2)

/// Example ideas of possible FFs
/// Voice
/// VoiceBiometricTextDependent   FeatureFlag = iota // Voice Auth Text Dependent (Enrollable)
/// VoiceBiometricTextIndependent                    // Voice Auth Text Independent (Enrollable)
/// VoiceBiometricWakeword                           // Voice Wakeword (Enrollable)
/// VoiceEventWakeword                               // Voice Wakeword
public enum Sensory_Api_Common_FeatureFlag: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// TssvAll feature set
  case tssvAll // = 0

  /// TsAll feature set
  case tsAll // = 1

  /// TnlAll feature set
  case tnlAll // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .tssvAll
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tssvAll
    case 1: self = .tsAll
    case 2: self = .tnlAll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tssvAll: return 0
    case .tsAll: return 1
    case .tnlAll: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_FeatureFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_FeatureFlag] = [
    .tssvAll,
    .tsAll,
    .tnlAll,
  ]
}

#endif  // swift(>=4.2)

/// A type of model supported by this API
/// Note: if you change this enum, ensure to update schema.prisma ModelType
public enum Sensory_Api_Common_ModelType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown Model Type
  case unknown // = 0

  /// Voice Auth Text Independent (Enrollable)
  case voiceBiometricTextIndependent // = 1

  /// Voice Wakeword (Enrollable)
  case voiceBiometricWakeword // = 2

  /// Voice Wakeword
  case voiceEventWakeword // = 3

  /// Voice Grammar Recognition such as LVCSR
  case voiceTranscribeGrammar // = 4

  /// Voice Commands and Search recognition
  case voiceTranscribeCommandAndSearch // = 5

  /// Voice activity detection
  case voiceRecognitionActivityDetection // = 6

  /// Voice feature extractor
  case voiceFeatureExtractor // = 7

  /// Voice digit recognizer for liveness
  case voiceBiometricLivenessDigit // = 8

  /// Voice Auth Text Dependent (Enrollable)
  case voiceBiometricTextDependent // = 9

  /// Voice Synthesis
  case voiceSynthesis // = 10

  /// Sound Event Auth (Enrollable)
  case soundEventEnrollable // = 100

  /// Sound Event Revalidation
  case soundEventRevalidation // = 101

  /// Sound Event Recognition
  case soundEventFixed // = 102

  /// Sound Scene Recognition
  case soundSceneFixed // = 103

  /// Face Auth (Enrollable)
  case faceBiometric // = 201

  /// Face Recognition
  case faceRecognition // = 202

  /// Object Recognition
  case objectRecognition // = 203

  /// Image Transformation
  case imageTransform // = 204

  /// Face Embedding
  case faceEmbedding // = 205

  /// Large Language Model
  case llmGpt35 // = 301
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .voiceBiometricTextIndependent
    case 2: self = .voiceBiometricWakeword
    case 3: self = .voiceEventWakeword
    case 4: self = .voiceTranscribeGrammar
    case 5: self = .voiceTranscribeCommandAndSearch
    case 6: self = .voiceRecognitionActivityDetection
    case 7: self = .voiceFeatureExtractor
    case 8: self = .voiceBiometricLivenessDigit
    case 9: self = .voiceBiometricTextDependent
    case 10: self = .voiceSynthesis
    case 100: self = .soundEventEnrollable
    case 101: self = .soundEventRevalidation
    case 102: self = .soundEventFixed
    case 103: self = .soundSceneFixed
    case 201: self = .faceBiometric
    case 202: self = .faceRecognition
    case 203: self = .objectRecognition
    case 204: self = .imageTransform
    case 205: self = .faceEmbedding
    case 301: self = .llmGpt35
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .voiceBiometricTextIndependent: return 1
    case .voiceBiometricWakeword: return 2
    case .voiceEventWakeword: return 3
    case .voiceTranscribeGrammar: return 4
    case .voiceTranscribeCommandAndSearch: return 5
    case .voiceRecognitionActivityDetection: return 6
    case .voiceFeatureExtractor: return 7
    case .voiceBiometricLivenessDigit: return 8
    case .voiceBiometricTextDependent: return 9
    case .voiceSynthesis: return 10
    case .soundEventEnrollable: return 100
    case .soundEventRevalidation: return 101
    case .soundEventFixed: return 102
    case .soundSceneFixed: return 103
    case .faceBiometric: return 201
    case .faceRecognition: return 202
    case .objectRecognition: return 203
    case .imageTransform: return 204
    case .faceEmbedding: return 205
    case .llmGpt35: return 301
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_ModelType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_ModelType] = [
    .unknown,
    .voiceBiometricTextIndependent,
    .voiceBiometricWakeword,
    .voiceEventWakeword,
    .voiceTranscribeGrammar,
    .voiceTranscribeCommandAndSearch,
    .voiceRecognitionActivityDetection,
    .voiceFeatureExtractor,
    .voiceBiometricLivenessDigit,
    .voiceBiometricTextDependent,
    .voiceSynthesis,
    .soundEventEnrollable,
    .soundEventRevalidation,
    .soundEventFixed,
    .soundSceneFixed,
    .faceBiometric,
    .faceRecognition,
    .objectRecognition,
    .imageTransform,
    .faceEmbedding,
    .llmGpt35,
  ]
}

#endif  // swift(>=4.2)

/// An enum denoting the type of Sensory technology employed
public enum Sensory_Api_Common_TechnologyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not Set type - used internally
  case notSet // = 0

  /// Truly Secure Speaker Verification, an audio authentication and wakeword tool
  case tssv // = 1

  /// Truly Secure, a face identification and liveness suite
  case ts // = 2

  /// Truly Natural, a wakeword and speech recognition tool
  case tnl // = 3

  /// Speech to Text, a large scale neural speech recognition tool
  case stt // = 4

  /// Text to Speech, a voice synthesis tool
  case tts // = 5

  /// Sound Id, a sound identification tool
  case soundID // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .tssv
    case 2: self = .ts
    case 3: self = .tnl
    case 4: self = .stt
    case 5: self = .tts
    case 6: self = .soundID
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .tssv: return 1
    case .ts: return 2
    case .tnl: return 3
    case .stt: return 4
    case .tts: return 5
    case .soundID: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_TechnologyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_TechnologyType] = [
    .notSet,
    .tssv,
    .ts,
    .tnl,
    .stt,
    .tts,
    .soundID,
  ]
}

#endif  // swift(>=4.2)

/// Every type of compression that is supported
/// Note: if you change this enum, ensure to update schema.prisma CompressionType
public enum Sensory_Api_Common_CompressionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Image data is in grayscale instead of full color
  case imageGrayscale // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .imageGrayscale
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .imageGrayscale
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .imageGrayscale: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_CompressionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_CompressionType] = [
    .imageGrayscale,
  ]
}

#endif  // swift(>=4.2)

/// Possible client types
public enum Sensory_Api_Common_ClientType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Invalid, not set role
  case invalid // = 0

  /// User End Device       (E.G. Sensory SDK on Smartphone)
  case device // = 1

  /// Remote Cluster        (E.G. Customer-Deployed Io Cluster)
  case cluster // = 2

  /// User Account          (E.G. Customer-Portal)
  case user // = 3

  /// Super User Account    (E.G. Admin)
  case superUser // = 4

  /// Billing User Account   (E.G. CFO)
  case billingUser // = 5

  /// Read-Only Account
  case readOnlyUser // = 6

  /// Sensory Root Token
  case root // = 100
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .device
    case 2: self = .cluster
    case 3: self = .user
    case 4: self = .superUser
    case 5: self = .billingUser
    case 6: self = .readOnlyUser
    case 100: self = .root
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .device: return 1
    case .cluster: return 2
    case .user: return 3
    case .superUser: return 4
    case .billingUser: return 5
    case .readOnlyUser: return 6
    case .root: return 100
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_ClientType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_ClientType] = [
    .invalid,
    .device,
    .cluster,
    .user,
    .superUser,
    .billingUser,
    .readOnlyUser,
    .root,
  ]
}

#endif  // swift(>=4.2)

/// Possible usage event type
/// Note: if you change this enum, ensure to update schema.prisma EventType
public enum Sensory_Api_Common_UsageEventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Authentication usage event
  case authentication // = 0

  /// Recognition usage event
  case recognition // = 1

  /// Enrollment usage event
  case enrollment // = 2

  /// Synthesis usage event
  case synthesis // = 3

  /// Speech to text usage event
  case transcription // = 4

  /// Large Language Model
  case llm // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .authentication
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authentication
    case 1: self = .recognition
    case 2: self = .enrollment
    case 3: self = .synthesis
    case 4: self = .transcription
    case 5: self = .llm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .authentication: return 0
    case .recognition: return 1
    case .enrollment: return 2
    case .synthesis: return 3
    case .transcription: return 4
    case .llm: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_UsageEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_UsageEventType] = [
    .authentication,
    .recognition,
    .enrollment,
    .synthesis,
    .transcription,
    .llm,
  ]
}

#endif  // swift(>=4.2)

/// Possible types of servers
public enum Sensory_Api_Common_ServerType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case titan // = 0
  case io // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .titan
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .titan
    case 1: self = .io
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .titan: return 0
    case .io: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_ServerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_ServerType] = [
    .titan,
    .io,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for how data can be compressed
public struct Sensory_Api_Common_CompressionConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of every compression method that was used
  public var compressions: [Sensory_Api_Common_CompressionType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from a successful token request
public struct Sensory_Api_Common_TokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signed JSON web token that should be added to any subsequent request
  public var accessToken: String = String()

  /// Number of seconds until this token will expire
  public var expiresIn: Int32 = 0

  /// Signing key identifier which can be used to retrieve the matching public key via the GetPublicKey request
  public var keyID: String = String()

  /// Token type
  public var tokenType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An indication of the health of a particular service
public struct Sensory_Api_Common_ServiceHealth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is healthy indication
  public var isHealthy: Bool = false

  /// Name of the service
  public var name: String = String()

  /// Details of the service health
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from a GetHealth request
public struct Sensory_Api_Common_ServerHealthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is healthy indication. True if all services are healthy.
  public var isHealthy: Bool = false

  /// Currently running server version
  public var serverVersion: String = String()

  /// Unique Identifier for the particular server
  public var id: String = String()

  /// List of services and their health statuses
  public var services: [Sensory_Api_Common_ServiceHealth] = []

  /// The type of server that is sending the health response
  public var serverType: Sensory_Api_Common_ServerType = .titan

  public var isLeader: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A summary of system statistics
public struct Sensory_Api_Common_SystemSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cpu: Sensory_Api_Common_CpuSummary {
    get {return _cpu ?? Sensory_Api_Common_CpuSummary()}
    set {_cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  public var hasCpu: Bool {return self._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  public mutating func clearCpu() {self._cpu = nil}

  public var memory: Sensory_Api_Common_MemorySummary {
    get {return _memory ?? Sensory_Api_Common_MemorySummary()}
    set {_memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  public var hasMemory: Bool {return self._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  public mutating func clearMemory() {self._memory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cpu: Sensory_Api_Common_CpuSummary? = nil
  fileprivate var _memory: Sensory_Api_Common_MemorySummary? = nil
}

/// Summary of all CPU useage as measured in ticks
public struct Sensory_Api_Common_CpuSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// normal processes executing in user mode
  public var user: UInt64 = 0

  /// niced processes executing in user mode
  public var nice: UInt64 = 0

  /// processes executing in kernel mode
  public var system: UInt64 = 0

  /// idle cpu
  public var idle: UInt64 = 0

  /// waiting for I/O to complete
  public var ioWait: UInt64 = 0

  /// servicing interrupts
  public var irq: UInt64 = 0

  /// servicing softirqs
  public var softIrq: UInt64 = 0

  /// counts the ticks spent executing other virtual hosts
  public var steal: UInt64 = 0

  /// counts the time spent running a virtual CPU for guest operating systems under the control of the Linux kernel
  public var guest: UInt64 = 0

  /// time spent running a niced guest
  public var guestNice: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A summary of memory usage
public struct Sensory_Api_Common_MemorySummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total memory in use
  public var memTotal: UInt64 = 0

  /// total memory free
  public var memFree: UInt64 = 0

  /// total memory available by the system
  public var memAvailable: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create a generic client. Client type should be inferred by usage.
/// This data should be stored securely on the client endpoint.
public struct Sensory_Api_Common_GenericClient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique Client ID as UUID
  public var clientID: String = String()

  /// Strong secret value (min length of 10)
  public var secret: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tenant response
public struct Sensory_Api_Common_TenantResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique uuid for this tenant
  public var id: String = String()

  /// The unique name for this tenant
  public var name: String = String()

  /// Created timestamp
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  /// Last updated timestamp
  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A message for telling the server how to paginate and order data
public struct Sensory_Api_Common_PaginationOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parameter to order the data by. If empty, the server will choose a default ordering
  public var ordering: String = String()

  /// If "True" the data will be sorted in decending order
  public var decending: Bool = false

  /// The page index to return
  public var pageIndex: Int32 = 0

  /// The preferred number of elements per page. If zero the server will choose a default size
  /// The server enforces a maximum page size of 100
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message for the server to tell how the data has been paginated
public struct Sensory_Api_Common_PaginationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parameter by which the data has been ordered by
  public var ordering: String = String()

  /// "True" if the data has been sorted in decending order
  public var decending: Bool = false

  /// A list of all possible parameters that the data can be ordered by
  public var possibleOrderings: [String] = []

  /// The total count of data objects
  public var totalCount: Int64 = 0

  /// The page size of the data
  public var pageSize: Int32 = 0

  /// The page index for the previous page. If negative there is no previous page
  public var prevPageIndex: Int32 = 0

  /// The page index for the current page.
  public var currentPageIndex: Int32 = 0

  /// The page index for the next page. If negative there is no next page
  public var nextPageIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message with an encrypted enrollment token and a token expiration date
public struct Sensory_Api_Common_EnrollmentToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encrypted token containing enrollment information
  public var token: Data = Data()

  /// The number of seconds until the enrollment token expires
  /// An expiration of 0 means that the enrollment token never expires
  public var expiration: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to a key request. Holds a byte array representing the key value.
/// Also should we add a "userCreated" boolean or enum to the keys?
public struct Sensory_Api_Common_CreateKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name you'd like to associate with this key
  public var name: String = String()

  /// The key type
  public var keyType: Sensory_Api_Common_KeyType = .publicKey

  /// The value of the key as a string
  public var value: String = String()

  /// Optional seconds until this key expires
  public var expiration: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to a key request. Holds a byte array representing the key value.
public struct Sensory_Api_Common_KeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The the uuid associated with this key
  public var id: String = String()

  /// The name associated with this key
  public var name: String = String()

  /// The key type
  public var keyType: Sensory_Api_Common_KeyType = .publicKey

  /// Optional seconds until this key expires.
  /// If this value is 0, this key will never expire
  public var expiration: Int64 = 0

  /// TenantId for this key
  public var tenantID: String = String()

  /// Indicates if this key is disabled
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Sensory_Api_Common_Void: @unchecked Sendable {}
extension Sensory_Api_Common_KeyType: @unchecked Sendable {}
extension Sensory_Api_Common_FeatureFlag: @unchecked Sendable {}
extension Sensory_Api_Common_ModelType: @unchecked Sendable {}
extension Sensory_Api_Common_TechnologyType: @unchecked Sendable {}
extension Sensory_Api_Common_CompressionType: @unchecked Sendable {}
extension Sensory_Api_Common_ClientType: @unchecked Sendable {}
extension Sensory_Api_Common_UsageEventType: @unchecked Sendable {}
extension Sensory_Api_Common_ServerType: @unchecked Sendable {}
extension Sensory_Api_Common_CompressionConfiguration: @unchecked Sendable {}
extension Sensory_Api_Common_TokenResponse: @unchecked Sendable {}
extension Sensory_Api_Common_ServiceHealth: @unchecked Sendable {}
extension Sensory_Api_Common_ServerHealthResponse: @unchecked Sendable {}
extension Sensory_Api_Common_SystemSummary: @unchecked Sendable {}
extension Sensory_Api_Common_CpuSummary: @unchecked Sendable {}
extension Sensory_Api_Common_MemorySummary: @unchecked Sendable {}
extension Sensory_Api_Common_GenericClient: @unchecked Sendable {}
extension Sensory_Api_Common_TenantResponse: @unchecked Sendable {}
extension Sensory_Api_Common_PaginationOptions: @unchecked Sendable {}
extension Sensory_Api_Common_PaginationResponse: @unchecked Sendable {}
extension Sensory_Api_Common_EnrollmentToken: @unchecked Sendable {}
extension Sensory_Api_Common_CreateKeyRequest: @unchecked Sendable {}
extension Sensory_Api_Common_KeyResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sensory.api.common"

extension Sensory_Api_Common_Void: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOID_VALUE"),
  ]
}

extension Sensory_Api_Common_KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLIC_KEY"),
    1: .same(proto: "PUBLIC_KEY_ED25519"),
    3: .same(proto: "SHARED_SECRET"),
    4: .same(proto: "AES_256"),
  ]
}

extension Sensory_Api_Common_FeatureFlag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TSSV_ALL"),
    1: .same(proto: "TS_ALL"),
    2: .same(proto: "TNL_ALL"),
  ]
}

extension Sensory_Api_Common_ModelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "VOICE_BIOMETRIC_TEXT_INDEPENDENT"),
    2: .same(proto: "VOICE_BIOMETRIC_WAKEWORD"),
    3: .same(proto: "VOICE_EVENT_WAKEWORD"),
    4: .same(proto: "VOICE_TRANSCRIBE_GRAMMAR"),
    5: .same(proto: "VOICE_TRANSCRIBE_COMMAND_AND_SEARCH"),
    6: .same(proto: "VOICE_RECOGNITION_ACTIVITY_DETECTION"),
    7: .same(proto: "VOICE_FEATURE_EXTRACTOR"),
    8: .same(proto: "VOICE_BIOMETRIC_LIVENESS_DIGIT"),
    9: .same(proto: "VOICE_BIOMETRIC_TEXT_DEPENDENT"),
    10: .same(proto: "VOICE_SYNTHESIS"),
    100: .same(proto: "SOUND_EVENT_ENROLLABLE"),
    101: .same(proto: "SOUND_EVENT_REVALIDATION"),
    102: .same(proto: "SOUND_EVENT_FIXED"),
    103: .same(proto: "SOUND_SCENE_FIXED"),
    201: .same(proto: "FACE_BIOMETRIC"),
    202: .same(proto: "FACE_RECOGNITION"),
    203: .same(proto: "OBJECT_RECOGNITION"),
    204: .same(proto: "IMAGE_TRANSFORM"),
    205: .same(proto: "FACE_EMBEDDING"),
    301: .same(proto: "LLM_GPT_3_5"),
  ]
}

extension Sensory_Api_Common_TechnologyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SET"),
    1: .same(proto: "TSSV"),
    2: .same(proto: "TS"),
    3: .same(proto: "TNL"),
    4: .same(proto: "STT"),
    5: .same(proto: "TTS"),
    6: .same(proto: "SOUND_ID"),
  ]
}

extension Sensory_Api_Common_CompressionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMAGE_GRAYSCALE"),
  ]
}

extension Sensory_Api_Common_ClientType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID"),
    1: .same(proto: "DEVICE"),
    2: .same(proto: "CLUSTER"),
    3: .same(proto: "USER"),
    4: .same(proto: "SUPER_USER"),
    5: .same(proto: "BILLING_USER"),
    6: .same(proto: "READ_ONLY_USER"),
    100: .same(proto: "ROOT"),
  ]
}

extension Sensory_Api_Common_UsageEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION"),
    1: .same(proto: "RECOGNITION"),
    2: .same(proto: "ENROLLMENT"),
    3: .same(proto: "SYNTHESIS"),
    4: .same(proto: "TRANSCRIPTION"),
    5: .same(proto: "LLM"),
  ]
}

extension Sensory_Api_Common_ServerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TITAN"),
    1: .same(proto: "IO"),
  ]
}

extension Sensory_Api_Common_CompressionConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompressionConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "compressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.compressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.compressions.isEmpty {
      try visitor.visitPackedEnumField(value: self.compressions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_CompressionConfiguration, rhs: Sensory_Api_Common_CompressionConfiguration) -> Bool {
    if lhs.compressions != rhs.compressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_TokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accessToken"),
    2: .same(proto: "expiresIn"),
    3: .same(proto: "keyId"),
    4: .same(proto: "tokenType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expiresIn) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 1)
    }
    if self.expiresIn != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresIn, fieldNumber: 2)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 3)
    }
    if !self.tokenType.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_TokenResponse, rhs: Sensory_Api_Common_TokenResponse) -> Bool {
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.expiresIn != rhs.expiresIn {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_ServiceHealth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceHealth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isHealthy"),
    2: .same(proto: "name"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isHealthy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isHealthy != false {
      try visitor.visitSingularBoolField(value: self.isHealthy, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_ServiceHealth, rhs: Sensory_Api_Common_ServiceHealth) -> Bool {
    if lhs.isHealthy != rhs.isHealthy {return false}
    if lhs.name != rhs.name {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_ServerHealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerHealthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isHealthy"),
    2: .same(proto: "serverVersion"),
    3: .same(proto: "id"),
    4: .same(proto: "services"),
    5: .same(proto: "serverType"),
    6: .same(proto: "isLeader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isHealthy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.serverType) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isLeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isHealthy != false {
      try visitor.visitSingularBoolField(value: self.isHealthy, fieldNumber: 1)
    }
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 4)
    }
    if self.serverType != .titan {
      try visitor.visitSingularEnumField(value: self.serverType, fieldNumber: 5)
    }
    if self.isLeader != false {
      try visitor.visitSingularBoolField(value: self.isLeader, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_ServerHealthResponse, rhs: Sensory_Api_Common_ServerHealthResponse) -> Bool {
    if lhs.isHealthy != rhs.isHealthy {return false}
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs.id != rhs.id {return false}
    if lhs.services != rhs.services {return false}
    if lhs.serverType != rhs.serverType {return false}
    if lhs.isLeader != rhs.isLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_SystemSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cpu"),
    2: .same(proto: "memory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cpu) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cpu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_SystemSummary, rhs: Sensory_Api_Common_SystemSummary) -> Bool {
    if lhs._cpu != rhs._cpu {return false}
    if lhs._memory != rhs._memory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_CpuSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CpuSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "nice"),
    3: .same(proto: "system"),
    4: .same(proto: "idle"),
    5: .same(proto: "ioWait"),
    6: .same(proto: "irq"),
    7: .same(proto: "softIrq"),
    8: .same(proto: "steal"),
    9: .same(proto: "guest"),
    10: .same(proto: "guestNice"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.user) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nice) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.system) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.idle) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.ioWait) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.irq) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.softIrq) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.steal) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.guest) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.guestNice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.user != 0 {
      try visitor.visitSingularUInt64Field(value: self.user, fieldNumber: 1)
    }
    if self.nice != 0 {
      try visitor.visitSingularUInt64Field(value: self.nice, fieldNumber: 2)
    }
    if self.system != 0 {
      try visitor.visitSingularUInt64Field(value: self.system, fieldNumber: 3)
    }
    if self.idle != 0 {
      try visitor.visitSingularUInt64Field(value: self.idle, fieldNumber: 4)
    }
    if self.ioWait != 0 {
      try visitor.visitSingularUInt64Field(value: self.ioWait, fieldNumber: 5)
    }
    if self.irq != 0 {
      try visitor.visitSingularUInt64Field(value: self.irq, fieldNumber: 6)
    }
    if self.softIrq != 0 {
      try visitor.visitSingularUInt64Field(value: self.softIrq, fieldNumber: 7)
    }
    if self.steal != 0 {
      try visitor.visitSingularUInt64Field(value: self.steal, fieldNumber: 8)
    }
    if self.guest != 0 {
      try visitor.visitSingularUInt64Field(value: self.guest, fieldNumber: 9)
    }
    if self.guestNice != 0 {
      try visitor.visitSingularUInt64Field(value: self.guestNice, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_CpuSummary, rhs: Sensory_Api_Common_CpuSummary) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.nice != rhs.nice {return false}
    if lhs.system != rhs.system {return false}
    if lhs.idle != rhs.idle {return false}
    if lhs.ioWait != rhs.ioWait {return false}
    if lhs.irq != rhs.irq {return false}
    if lhs.softIrq != rhs.softIrq {return false}
    if lhs.steal != rhs.steal {return false}
    if lhs.guest != rhs.guest {return false}
    if lhs.guestNice != rhs.guestNice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_MemorySummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemorySummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memTotal"),
    2: .same(proto: "memFree"),
    3: .same(proto: "memAvailable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memTotal) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memFree) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.memAvailable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memTotal != 0 {
      try visitor.visitSingularUInt64Field(value: self.memTotal, fieldNumber: 1)
    }
    if self.memFree != 0 {
      try visitor.visitSingularUInt64Field(value: self.memFree, fieldNumber: 2)
    }
    if self.memAvailable != 0 {
      try visitor.visitSingularUInt64Field(value: self.memAvailable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_MemorySummary, rhs: Sensory_Api_Common_MemorySummary) -> Bool {
    if lhs.memTotal != rhs.memTotal {return false}
    if lhs.memFree != rhs.memFree {return false}
    if lhs.memAvailable != rhs.memAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_GenericClient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenericClient"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientId"),
    2: .same(proto: "secret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_GenericClient, rhs: Sensory_Api_Common_GenericClient) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_TenantResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TenantResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "createdAt"),
    4: .same(proto: "updatedAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_TenantResponse, rhs: Sensory_Api_Common_TenantResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_PaginationOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaginationOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ordering"),
    2: .same(proto: "decending"),
    3: .same(proto: "pageIndex"),
    4: .same(proto: "pageSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ordering) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.decending) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageIndex) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ordering.isEmpty {
      try visitor.visitSingularStringField(value: self.ordering, fieldNumber: 1)
    }
    if self.decending != false {
      try visitor.visitSingularBoolField(value: self.decending, fieldNumber: 2)
    }
    if self.pageIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.pageIndex, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_PaginationOptions, rhs: Sensory_Api_Common_PaginationOptions) -> Bool {
    if lhs.ordering != rhs.ordering {return false}
    if lhs.decending != rhs.decending {return false}
    if lhs.pageIndex != rhs.pageIndex {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_PaginationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaginationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ordering"),
    2: .same(proto: "decending"),
    3: .same(proto: "possibleOrderings"),
    4: .same(proto: "totalCount"),
    5: .same(proto: "pageSize"),
    6: .same(proto: "prevPageIndex"),
    7: .same(proto: "currentPageIndex"),
    8: .same(proto: "nextPageIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ordering) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.decending) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.possibleOrderings) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.prevPageIndex) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.currentPageIndex) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.nextPageIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ordering.isEmpty {
      try visitor.visitSingularStringField(value: self.ordering, fieldNumber: 1)
    }
    if self.decending != false {
      try visitor.visitSingularBoolField(value: self.decending, fieldNumber: 2)
    }
    if !self.possibleOrderings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.possibleOrderings, fieldNumber: 3)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 5)
    }
    if self.prevPageIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.prevPageIndex, fieldNumber: 6)
    }
    if self.currentPageIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.currentPageIndex, fieldNumber: 7)
    }
    if self.nextPageIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.nextPageIndex, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_PaginationResponse, rhs: Sensory_Api_Common_PaginationResponse) -> Bool {
    if lhs.ordering != rhs.ordering {return false}
    if lhs.decending != rhs.decending {return false}
    if lhs.possibleOrderings != rhs.possibleOrderings {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.prevPageIndex != rhs.prevPageIndex {return false}
    if lhs.currentPageIndex != rhs.currentPageIndex {return false}
    if lhs.nextPageIndex != rhs.nextPageIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_EnrollmentToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnrollmentToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "expiration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expiration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_EnrollmentToken, rhs: Sensory_Api_Common_EnrollmentToken) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_CreateKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "keyType"),
    3: .same(proto: "value"),
    4: .same(proto: "expiration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.keyType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expiration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.keyType != .publicKey {
      try visitor.visitSingularEnumField(value: self.keyType, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_CreateKeyRequest, rhs: Sensory_Api_Common_CreateKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.value != rhs.value {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_KeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "keyType"),
    4: .same(proto: "expiration"),
    5: .same(proto: "tenantId"),
    6: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.keyType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expiration) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tenantID) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.keyType != .publicKey {
      try visitor.visitSingularEnumField(value: self.keyType, fieldNumber: 3)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 4)
    }
    if !self.tenantID.isEmpty {
      try visitor.visitSingularStringField(value: self.tenantID, fieldNumber: 5)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_KeyResponse, rhs: Sensory_Api_Common_KeyResponse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
