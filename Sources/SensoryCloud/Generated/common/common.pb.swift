// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// sensory.api.common

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A type of key supported by the API
/// Note: if you change this enum, ensure to update schema.prisma KeyType
public enum Sensory_Api_Common_KeyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// General Public key - kept for backwards compatability
  case publicKey // = 0

  /// ED25519 Public key used for asymmetric cryptographic operations
  case publicKeyEd25519 // = 1

  /// Shared secret string
  case sharedSecret // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .publicKey
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .publicKey
    case 1: self = .publicKeyEd25519
    case 3: self = .sharedSecret
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .publicKey: return 0
    case .publicKeyEd25519: return 1
    case .sharedSecret: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_KeyType] = [
    .publicKey,
    .publicKeyEd25519,
    .sharedSecret,
  ]
}

#endif  // swift(>=4.2)

/// A type of model supported by this API
/// Note: if you change this enum, ensure to update schema.prisma ModelType
public enum Sensory_Api_Common_ModelType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Voice Auth Text Dependent (Enrollable)
  case voiceBiometricTextDependent // = 0

  /// Voice Auth Text Independent (Enrollable)
  case voiceBiometricTextIndependent // = 1

  /// Voice Wakeword (Enrollable)
  case voiceBiometricWakeword // = 2

  /// Voice Wakeword
  case voiceEventWakeword // = 3

  /// Voice Grammar Recognition such as LVCSR
  case voiceTranscribeGrammar // = 4

  /// Voice Commands and Search recognition
  case voiceTranscribeCommandAndSearch // = 5

  /// Voice activity detection
  case voiceRecognitionActivityDetection // = 6

  /// Voice feature extractor
  case voiceFeatureExtractor // = 7

  /// Voice digit recognizer for liveness
  case voiceBiometricLivenessDigit // = 8

  /// Sound Event Auth (Enrollable)
  case soundEventEnrollable // = 100

  /// Sound Event Revalidation
  case soundEventRevalidation // = 101

  /// Sound Event Recognition
  case soundEventFixed // = 102

  /// Sound Scene Recognition
  case soundSceneFixed // = 103

  /// Face Auth (Enrollable)
  case faceBiometric // = 201

  /// Face Recognition
  case faceRecognition // = 202

  /// Object Recognition
  case objectRecognition // = 203

  /// Image Transformation
  case imageTransform // = 204

  /// Unknown Model Type
  case unknown // = 1000
  case UNRECOGNIZED(Int)

  public init() {
    self = .voiceBiometricTextDependent
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .voiceBiometricTextDependent
    case 1: self = .voiceBiometricTextIndependent
    case 2: self = .voiceBiometricWakeword
    case 3: self = .voiceEventWakeword
    case 4: self = .voiceTranscribeGrammar
    case 5: self = .voiceTranscribeCommandAndSearch
    case 6: self = .voiceRecognitionActivityDetection
    case 7: self = .voiceFeatureExtractor
    case 8: self = .voiceBiometricLivenessDigit
    case 100: self = .soundEventEnrollable
    case 101: self = .soundEventRevalidation
    case 102: self = .soundEventFixed
    case 103: self = .soundSceneFixed
    case 201: self = .faceBiometric
    case 202: self = .faceRecognition
    case 203: self = .objectRecognition
    case 204: self = .imageTransform
    case 1000: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .voiceBiometricTextDependent: return 0
    case .voiceBiometricTextIndependent: return 1
    case .voiceBiometricWakeword: return 2
    case .voiceEventWakeword: return 3
    case .voiceTranscribeGrammar: return 4
    case .voiceTranscribeCommandAndSearch: return 5
    case .voiceRecognitionActivityDetection: return 6
    case .voiceFeatureExtractor: return 7
    case .voiceBiometricLivenessDigit: return 8
    case .soundEventEnrollable: return 100
    case .soundEventRevalidation: return 101
    case .soundEventFixed: return 102
    case .soundSceneFixed: return 103
    case .faceBiometric: return 201
    case .faceRecognition: return 202
    case .objectRecognition: return 203
    case .imageTransform: return 204
    case .unknown: return 1000
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_ModelType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_ModelType] = [
    .voiceBiometricTextDependent,
    .voiceBiometricTextIndependent,
    .voiceBiometricWakeword,
    .voiceEventWakeword,
    .voiceTranscribeGrammar,
    .voiceTranscribeCommandAndSearch,
    .voiceRecognitionActivityDetection,
    .voiceFeatureExtractor,
    .voiceBiometricLivenessDigit,
    .soundEventEnrollable,
    .soundEventRevalidation,
    .soundEventFixed,
    .soundSceneFixed,
    .faceBiometric,
    .faceRecognition,
    .objectRecognition,
    .imageTransform,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

/// An enum denoting the type of Sensory technology employed
public enum Sensory_Api_Common_TechnologyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not Set type - used internally
  case notSet // = 0

  /// Truly Secure Speaker Verification, an audio authentication and wakeword tool
  case tssv // = 1

  /// Truly Secure, a face identification and liveness suite
  case ts // = 2

  /// Truly Natural, a wakeword and speech recognition tool
  case tnl // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSet
    case 1: self = .tssv
    case 2: self = .ts
    case 3: self = .tnl
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notSet: return 0
    case .tssv: return 1
    case .ts: return 2
    case .tnl: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_TechnologyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_TechnologyType] = [
    .notSet,
    .tssv,
    .ts,
    .tnl,
  ]
}

#endif  // swift(>=4.2)

/// Every type of compression that is supported
/// Note: if you change this enum, ensure to update schema.prisma CompressionType
public enum Sensory_Api_Common_CompressionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Image data is in grayscale instead of full color
  case imageGrayscale // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .imageGrayscale
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .imageGrayscale
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .imageGrayscale: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_CompressionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_CompressionType] = [
    .imageGrayscale,
  ]
}

#endif  // swift(>=4.2)

/// Possible client types
public enum Sensory_Api_Common_ClientType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Sensory Root Token
  case root // = 0

  /// User End Device (E.G. Sensory SDK on Smartphone)
  case device // = 1

  /// Remote Cluster   (E.G. Customer-Deployed Io Cluster)
  case cluster // = 2

  /// User Account    (E.G. Customer-Portal)
  case user // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .root
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .root
    case 1: self = .device
    case 2: self = .cluster
    case 3: self = .user
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .root: return 0
    case .device: return 1
    case .cluster: return 2
    case .user: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_ClientType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_ClientType] = [
    .root,
    .device,
    .cluster,
    .user,
  ]
}

#endif  // swift(>=4.2)

/// Possible usage event type
/// Note: if you change this enum, ensure to update schema.prisma EventType
public enum Sensory_Api_Common_UsageEventType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Authentication usage event
  case authentication // = 0

  /// Recognition usage event
  case recognition // = 1

  /// Enrollment usage event
  case enrollment // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .authentication
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authentication
    case 1: self = .recognition
    case 2: self = .enrollment
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .authentication: return 0
    case .recognition: return 1
    case .enrollment: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_Common_UsageEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_Common_UsageEventType] = [
    .authentication,
    .recognition,
    .enrollment,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for how data can be compressed
public struct Sensory_Api_Common_CompressionConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of every compression method that was used
  public var compressions: [Sensory_Api_Common_CompressionType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from a successful token request
public struct Sensory_Api_Common_TokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signed JSON web token that should be added to any subsequent request
  public var accessToken: String = String()

  /// Number of seconds until this token will expire
  public var expiresIn: Int32 = 0

  /// Signing key identifier which can be used to retrieve the matching public key via the GetPublicKey request
  public var keyID: String = String()

  /// Token type
  public var tokenType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An indication of the health of a particular service
public struct Sensory_Api_Common_ServiceHealth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is healthy indication
  public var isHealthy: Bool = false

  /// Name of the service
  public var name: String = String()

  /// Details of the service health
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from a GetHealth request
public struct Sensory_Api_Common_ServerHealthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is healthy indication. True if all services are healthy.
  public var isHealthy: Bool = false

  /// Currently running server version
  public var serverVersion: String = String()

  /// Unique Identifier for the particular server
  public var id: String = String()

  /// List of services and their health statuses
  public var services: [Sensory_Api_Common_ServiceHealth] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A summary of system statistics
public struct Sensory_Api_Common_SystemSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cpu: Sensory_Api_Common_CpuSummary {
    get {return _cpu ?? Sensory_Api_Common_CpuSummary()}
    set {_cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  public var hasCpu: Bool {return self._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  public mutating func clearCpu() {self._cpu = nil}

  public var memory: Sensory_Api_Common_MemorySummary {
    get {return _memory ?? Sensory_Api_Common_MemorySummary()}
    set {_memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  public var hasMemory: Bool {return self._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  public mutating func clearMemory() {self._memory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cpu: Sensory_Api_Common_CpuSummary? = nil
  fileprivate var _memory: Sensory_Api_Common_MemorySummary? = nil
}

/// Summary of all CPU useage as measured in ticks
public struct Sensory_Api_Common_CpuSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// normal processes executing in user mode
  public var user: UInt64 = 0

  /// niced processes executing in user mode
  public var nice: UInt64 = 0

  /// processes executing in kernel mode
  public var system: UInt64 = 0

  /// idle cpu
  public var idle: UInt64 = 0

  /// waiting for I/O to complete
  public var ioWait: UInt64 = 0

  /// servicing interrupts
  public var irq: UInt64 = 0

  /// servicing softirqs
  public var softIrq: UInt64 = 0

  /// counts the ticks spent executing other virtual hosts
  public var steal: UInt64 = 0

  /// counts the time spent running a virtual CPU for guest operating systems under the control of the Linux kernel
  public var guest: UInt64 = 0

  /// time spent running a niced guest
  public var guestNice: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A summary of memory usage
public struct Sensory_Api_Common_MemorySummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total memory in use
  public var memTotal: UInt64 = 0

  /// total memory free
  public var memFree: UInt64 = 0

  /// total memory available by the system
  public var memAvailable: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create a generic client. Client type should be inferred by usage.
/// This data should be stored securely on the client endpoint.
public struct Sensory_Api_Common_GenericClient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique Client ID as UUID
  public var clientID: String = String()

  /// Strong secret value (min length of 10)
  public var secret: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sensory.api.common"

extension Sensory_Api_Common_KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLIC_KEY"),
    1: .same(proto: "PUBLIC_KEY_ED25519"),
    3: .same(proto: "SHARED_SECRET"),
  ]
}

extension Sensory_Api_Common_ModelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_BIOMETRIC_TEXT_DEPENDENT"),
    1: .same(proto: "VOICE_BIOMETRIC_TEXT_INDEPENDENT"),
    2: .same(proto: "VOICE_BIOMETRIC_WAKEWORD"),
    3: .same(proto: "VOICE_EVENT_WAKEWORD"),
    4: .same(proto: "VOICE_TRANSCRIBE_GRAMMAR"),
    5: .same(proto: "VOICE_TRANSCRIBE_COMMAND_AND_SEARCH"),
    6: .same(proto: "VOICE_RECOGNITION_ACTIVITY_DETECTION"),
    7: .same(proto: "VOICE_FEATURE_EXTRACTOR"),
    8: .same(proto: "VOICE_BIOMETRIC_LIVENESS_DIGIT"),
    100: .same(proto: "SOUND_EVENT_ENROLLABLE"),
    101: .same(proto: "SOUND_EVENT_REVALIDATION"),
    102: .same(proto: "SOUND_EVENT_FIXED"),
    103: .same(proto: "SOUND_SCENE_FIXED"),
    201: .same(proto: "FACE_BIOMETRIC"),
    202: .same(proto: "FACE_RECOGNITION"),
    203: .same(proto: "OBJECT_RECOGNITION"),
    204: .same(proto: "IMAGE_TRANSFORM"),
    1000: .same(proto: "UNKNOWN"),
  ]
}

extension Sensory_Api_Common_TechnologyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SET"),
    1: .same(proto: "TSSV"),
    2: .same(proto: "TS"),
    3: .same(proto: "TNL"),
  ]
}

extension Sensory_Api_Common_CompressionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMAGE_GRAYSCALE"),
  ]
}

extension Sensory_Api_Common_ClientType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROOT"),
    1: .same(proto: "DEVICE"),
    2: .same(proto: "CLUSTER"),
    3: .same(proto: "USER"),
  ]
}

extension Sensory_Api_Common_UsageEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION"),
    1: .same(proto: "RECOGNITION"),
    2: .same(proto: "ENROLLMENT"),
  ]
}

extension Sensory_Api_Common_CompressionConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompressionConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "compressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.compressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.compressions.isEmpty {
      try visitor.visitPackedEnumField(value: self.compressions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_CompressionConfiguration, rhs: Sensory_Api_Common_CompressionConfiguration) -> Bool {
    if lhs.compressions != rhs.compressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_TokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accessToken"),
    2: .same(proto: "expiresIn"),
    3: .same(proto: "keyId"),
    4: .same(proto: "tokenType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.expiresIn) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 1)
    }
    if self.expiresIn != 0 {
      try visitor.visitSingularInt32Field(value: self.expiresIn, fieldNumber: 2)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 3)
    }
    if !self.tokenType.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_TokenResponse, rhs: Sensory_Api_Common_TokenResponse) -> Bool {
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.expiresIn != rhs.expiresIn {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_ServiceHealth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceHealth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isHealthy"),
    2: .same(proto: "name"),
    3: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isHealthy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isHealthy != false {
      try visitor.visitSingularBoolField(value: self.isHealthy, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_ServiceHealth, rhs: Sensory_Api_Common_ServiceHealth) -> Bool {
    if lhs.isHealthy != rhs.isHealthy {return false}
    if lhs.name != rhs.name {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_ServerHealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerHealthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isHealthy"),
    2: .same(proto: "serverVersion"),
    3: .same(proto: "id"),
    4: .same(proto: "services"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isHealthy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isHealthy != false {
      try visitor.visitSingularBoolField(value: self.isHealthy, fieldNumber: 1)
    }
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_ServerHealthResponse, rhs: Sensory_Api_Common_ServerHealthResponse) -> Bool {
    if lhs.isHealthy != rhs.isHealthy {return false}
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs.id != rhs.id {return false}
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_SystemSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cpu"),
    2: .same(proto: "memory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cpu) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cpu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._memory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_SystemSummary, rhs: Sensory_Api_Common_SystemSummary) -> Bool {
    if lhs._cpu != rhs._cpu {return false}
    if lhs._memory != rhs._memory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_CpuSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CpuSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "nice"),
    3: .same(proto: "system"),
    4: .same(proto: "idle"),
    5: .same(proto: "ioWait"),
    6: .same(proto: "irq"),
    7: .same(proto: "softIrq"),
    8: .same(proto: "steal"),
    9: .same(proto: "guest"),
    10: .same(proto: "guestNice"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.user) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nice) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.system) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.idle) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.ioWait) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.irq) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.softIrq) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.steal) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.guest) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.guestNice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.user != 0 {
      try visitor.visitSingularUInt64Field(value: self.user, fieldNumber: 1)
    }
    if self.nice != 0 {
      try visitor.visitSingularUInt64Field(value: self.nice, fieldNumber: 2)
    }
    if self.system != 0 {
      try visitor.visitSingularUInt64Field(value: self.system, fieldNumber: 3)
    }
    if self.idle != 0 {
      try visitor.visitSingularUInt64Field(value: self.idle, fieldNumber: 4)
    }
    if self.ioWait != 0 {
      try visitor.visitSingularUInt64Field(value: self.ioWait, fieldNumber: 5)
    }
    if self.irq != 0 {
      try visitor.visitSingularUInt64Field(value: self.irq, fieldNumber: 6)
    }
    if self.softIrq != 0 {
      try visitor.visitSingularUInt64Field(value: self.softIrq, fieldNumber: 7)
    }
    if self.steal != 0 {
      try visitor.visitSingularUInt64Field(value: self.steal, fieldNumber: 8)
    }
    if self.guest != 0 {
      try visitor.visitSingularUInt64Field(value: self.guest, fieldNumber: 9)
    }
    if self.guestNice != 0 {
      try visitor.visitSingularUInt64Field(value: self.guestNice, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_CpuSummary, rhs: Sensory_Api_Common_CpuSummary) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.nice != rhs.nice {return false}
    if lhs.system != rhs.system {return false}
    if lhs.idle != rhs.idle {return false}
    if lhs.ioWait != rhs.ioWait {return false}
    if lhs.irq != rhs.irq {return false}
    if lhs.softIrq != rhs.softIrq {return false}
    if lhs.steal != rhs.steal {return false}
    if lhs.guest != rhs.guest {return false}
    if lhs.guestNice != rhs.guestNice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_MemorySummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemorySummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "memTotal"),
    2: .same(proto: "memFree"),
    3: .same(proto: "memAvailable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memTotal) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memFree) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.memAvailable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memTotal != 0 {
      try visitor.visitSingularUInt64Field(value: self.memTotal, fieldNumber: 1)
    }
    if self.memFree != 0 {
      try visitor.visitSingularUInt64Field(value: self.memFree, fieldNumber: 2)
    }
    if self.memAvailable != 0 {
      try visitor.visitSingularUInt64Field(value: self.memAvailable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_MemorySummary, rhs: Sensory_Api_Common_MemorySummary) -> Bool {
    if lhs.memTotal != rhs.memTotal {return false}
    if lhs.memFree != rhs.memFree {return false}
    if lhs.memAvailable != rhs.memAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_Common_GenericClient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenericClient"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientId"),
    2: .same(proto: "secret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_Common_GenericClient, rhs: Sensory_Api_Common_GenericClient) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
