// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: v1/management/server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// sensory.api.management

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Generic NULL value
public enum Sensory_Api_V1_Management_Void: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case value // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .value
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .value
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .value: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_V1_Management_Void: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_V1_Management_Void] = [
    .value,
  ]
}

#endif  // swift(>=4.2)

/// Security level requirements for device enrollment
public enum Sensory_Api_V1_Management_DeviceEnrollmentSecurityLevels: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Public Enrollment with no security requirements
  case none // = 0

  /// Secret Key or shared secret enrollment
  case secretKey // = 1

  /// Signed Token, asymmetric cryptography
  case signedToken // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .secretKey
    case 2: self = .signedToken
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .secretKey: return 1
    case .signedToken: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sensory_Api_V1_Management_DeviceEnrollmentSecurityLevels: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Sensory_Api_V1_Management_DeviceEnrollmentSecurityLevels] = [
    .none,
    .secretKey,
    .signedToken,
  ]
}

#endif  // swift(>=4.2)

/// Request to get server configuration
public struct Sensory_Api_V1_Management_ServerConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Server configuration response
public struct Sensory_Api_V1_Management_ServerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tenant informoation for this server
  public var tenant: Sensory_Api_V1_Management_TenantResponse {
    get {return _storage._tenant ?? Sensory_Api_V1_Management_TenantResponse()}
    set {_uniqueStorage()._tenant = newValue}
  }
  /// Returns true if `tenant` has been explicitly set.
  public var hasTenant: Bool {return _storage._tenant != nil}
  /// Clears the value of `tenant`. Subsequent reads from it will return its default value.
  public mutating func clearTenant() {_uniqueStorage()._tenant = nil}

  /// Cluster information
  public var cluster: Sensory_Api_V1_Management_ClusterResponse {
    get {return _storage._cluster ?? Sensory_Api_V1_Management_ClusterResponse()}
    set {_uniqueStorage()._cluster = newValue}
  }
  /// Returns true if `cluster` has been explicitly set.
  public var hasCluster: Bool {return _storage._cluster != nil}
  /// Clears the value of `cluster`. Subsequent reads from it will return its default value.
  public mutating func clearCluster() {_uniqueStorage()._cluster = nil}

  /// Feature flags enabling specific server features
  public var featureFlags: [Int32] {
    get {return _storage._featureFlags}
    set {_uniqueStorage()._featureFlags = newValue}
  }

  /// Configuration for collecting prometheus metrucs
  public var prometheus: Sensory_Api_V1_Management_PrometheusConfig {
    get {return _storage._prometheus ?? Sensory_Api_V1_Management_PrometheusConfig()}
    set {_uniqueStorage()._prometheus = newValue}
  }
  /// Returns true if `prometheus` has been explicitly set.
  public var hasPrometheus: Bool {return _storage._prometheus != nil}
  /// Clears the value of `prometheus`. Subsequent reads from it will return its default value.
  public mutating func clearPrometheus() {_uniqueStorage()._prometheus = nil}

  /// Configuration for where/how to persist collected audio/video data
  public var dataPersistence: Sensory_Api_V1_Management_DataPersistenceConfig {
    get {return _storage._dataPersistence ?? Sensory_Api_V1_Management_DataPersistenceConfig()}
    set {_uniqueStorage()._dataPersistence = newValue}
  }
  /// Returns true if `dataPersistence` has been explicitly set.
  public var hasDataPersistence: Bool {return _storage._dataPersistence != nil}
  /// Clears the value of `dataPersistence`. Subsequent reads from it will return its default value.
  public mutating func clearDataPersistence() {_uniqueStorage()._dataPersistence = nil}

  /// Issuer to request OAuth tokens from
  public var oauthTokenIssuer: String {
    get {return _storage._oauthTokenIssuer}
    set {_uniqueStorage()._oauthTokenIssuer = newValue}
  }

  /// GRPC prot to broadcast on
  /// This value can be overwritten with the environmental variable "GRPC_PORT"
  public var grpcPort: String {
    get {return _storage._grpcPort}
    set {_uniqueStorage()._grpcPort = newValue}
  }

  /// Web GRPC port to broadcast on
  /// This value can be overwritten with the environmental variable "WEB_GRPC_PORT"
  public var webGrpcPort: String {
    get {return _storage._webGrpcPort}
    set {_uniqueStorage()._webGrpcPort = newValue}
  }

  /// Host for the Triton server
  /// This value can be overwritten with the environmental variable "TRITON_HOST"
  public var tritonHost: String {
    get {return _storage._tritonHost}
    set {_uniqueStorage()._tritonHost = newValue}
  }

  /// URL for the local database
  /// This value can be overwritten with the environmental variable "DATABASE_URL"
  public var databaseURL: String {
    get {return _storage._databaseURL}
    set {_uniqueStorage()._databaseURL = newValue}
  }

  /// Controls the security requirements and configuration for device enrollment
  public var deviceEnrollmentConfig: Sensory_Api_V1_Management_DeviceEnrollmentConfig {
    get {return _storage._deviceEnrollmentConfig ?? Sensory_Api_V1_Management_DeviceEnrollmentConfig()}
    set {_uniqueStorage()._deviceEnrollmentConfig = newValue}
  }
  /// Returns true if `deviceEnrollmentConfig` has been explicitly set.
  public var hasDeviceEnrollmentConfig: Bool {return _storage._deviceEnrollmentConfig != nil}
  /// Clears the value of `deviceEnrollmentConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceEnrollmentConfig() {_uniqueStorage()._deviceEnrollmentConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Configurations for prometheus metrics
public struct Sensory_Api_V1_Management_PrometheusConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URL to push metrics to
  public var url: String = String()

  /// Password for the prometheus pushgateway
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for where to save collected audio/vido data
public struct Sensory_Api_V1_Management_DataPersistenceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes the method of data persistence
  public var persistenceType: Sensory_Api_V1_Management_DataPersistenceConfig.OneOf_PersistenceType? = nil

  /// Data persistence is not persisted
  public var none: Sensory_Api_V1_Management_Void {
    get {
      if case .none(let v)? = persistenceType {return v}
      return .value
    }
    set {persistenceType = .none(newValue)}
  }

  /// Data is persisted under a local directory
  public var localConfig: Sensory_Api_V1_Management_DataPersistenceLocalConfig {
    get {
      if case .localConfig(let v)? = persistenceType {return v}
      return Sensory_Api_V1_Management_DataPersistenceLocalConfig()
    }
    set {persistenceType = .localConfig(newValue)}
  }

  /// Data is persisted to an S3 bucket
  public var s3Config: Sensory_Api_V1_Management_DataPersistenceS3Config {
    get {
      if case .s3Config(let v)? = persistenceType {return v}
      return Sensory_Api_V1_Management_DataPersistenceS3Config()
    }
    set {persistenceType = .s3Config(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the method of data persistence
  public enum OneOf_PersistenceType: Equatable {
    /// Data persistence is not persisted
    case none(Sensory_Api_V1_Management_Void)
    /// Data is persisted under a local directory
    case localConfig(Sensory_Api_V1_Management_DataPersistenceLocalConfig)
    /// Data is persisted to an S3 bucket
    case s3Config(Sensory_Api_V1_Management_DataPersistenceS3Config)

  #if !swift(>=4.1)
    public static func ==(lhs: Sensory_Api_V1_Management_DataPersistenceConfig.OneOf_PersistenceType, rhs: Sensory_Api_V1_Management_DataPersistenceConfig.OneOf_PersistenceType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.none, .none): return {
        guard case .none(let l) = lhs, case .none(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localConfig, .localConfig): return {
        guard case .localConfig(let l) = lhs, case .localConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.s3Config, .s3Config): return {
        guard case .s3Config(let l) = lhs, case .s3Config(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A heartbeat request sent from a server to the cloud
public struct Sensory_Api_V1_Management_ServerHeartbeatRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The UTC timestamp in seconds
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  /// The summary of service healths for the server along with server version and other information
  public var health: Sensory_Api_Common_ServerHealthResponse {
    get {return _storage._health ?? Sensory_Api_Common_ServerHealthResponse()}
    set {_uniqueStorage()._health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  public var hasHealth: Bool {return _storage._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  public mutating func clearHealth() {_uniqueStorage()._health = nil}

  /// General system health such as CPU and memory useage
  public var system: Sensory_Api_Common_SystemSummary {
    get {return _storage._system ?? Sensory_Api_Common_SystemSummary()}
    set {_uniqueStorage()._system = newValue}
  }
  /// Returns true if `system` has been explicitly set.
  public var hasSystem: Bool {return _storage._system != nil}
  /// Clears the value of `system`. Subsequent reads from it will return its default value.
  public mutating func clearSystem() {_uniqueStorage()._system = nil}

  /// User summary such as user count
  public var users: Sensory_Api_V1_Management_UserSummary {
    get {return _storage._users ?? Sensory_Api_V1_Management_UserSummary()}
    set {_uniqueStorage()._users = newValue}
  }
  /// Returns true if `users` has been explicitly set.
  public var hasUsers: Bool {return _storage._users != nil}
  /// Clears the value of `users`. Subsequent reads from it will return its default value.
  public mutating func clearUsers() {_uniqueStorage()._users = nil}

  /// Device summary such as devoce count
  public var devices: Sensory_Api_V1_Management_DeviceSummary {
    get {return _storage._devices ?? Sensory_Api_V1_Management_DeviceSummary()}
    set {_uniqueStorage()._devices = newValue}
  }
  /// Returns true if `devices` has been explicitly set.
  public var hasDevices: Bool {return _storage._devices != nil}
  /// Clears the value of `devices`. Subsequent reads from it will return its default value.
  public mutating func clearDevices() {_uniqueStorage()._devices = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The response from a heartbeat request
public struct Sensory_Api_V1_Management_HeartbeatResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server's configuration
  public var config: Sensory_Api_V1_Management_ServerConfig {
    get {return _config ?? Sensory_Api_V1_Management_ServerConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Sensory_Api_V1_Management_ServerConfig? = nil
}

/// A summary of users managed by the server
public struct Sensory_Api_V1_Management_UserSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of managed users
  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A summary of devices managed by the server
public struct Sensory_Api_V1_Management_DeviceSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of managed devices
  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration specifying how devices may be enrolled into the system
public struct Sensory_Api_V1_Management_DeviceEnrollmentConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var securityLevel: Sensory_Api_V1_Management_DeviceEnrollmentSecurityLevels = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for local data persistence
public struct Sensory_Api_V1_Management_DataPersistenceLocalConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Local path to persist data under
  /// This value can be overwritten with the environmental variable "DATA_PERSISTENCE_LOCAL_PATH"
  public var localPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for S3 data persistence
public struct Sensory_Api_V1_Management_DataPersistenceS3Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// S3 Access Key
  /// This value can be overwritten with the environmental variable "DATA_PERSISTENCE_S3_ACCESS_KEY"
  public var s3AccessKey: String = String()

  /// S3 Secret Key
  /// This value can be overwritten with the environmental variable "DATA_PERSISTENCE_S3_SECRET_KEY"
  public var s3SecretKey: String = String()

  /// S3 Region to persist data under
  /// This value can be overwritten with the environmental variable "DATA_PERSISTENCE_S3_REGION"
  public var s3Region: String = String()

  /// S3 Bucket to persist data under
  /// This value can be overwritten with the environmental variable "DATA_PERSISTENCE_S3_BUCKET"
  public var s3Bucket: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for a list of servers
public struct Sensory_Api_V1_Management_ServerListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional tenantId which must be a UUID. If this id is omitted, the summary will be across all tenants.
  public var tenantID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to a Server list request
public struct Sensory_Api_V1_Management_ServerListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of servers
  public var servers: [Sensory_Api_V1_Management_ServerResponse] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to a server request
public struct Sensory_Api_V1_Management_ServerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique uuid for this server
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The unique name for this server
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Indication of if this server is deployed remotely (true) or in our cloud (false)
  public var isRemote: Bool {
    get {return _storage._isRemote}
    set {_uniqueStorage()._isRemote = newValue}
  }

  /// Cluster this server is associated with
  public var clusterID: String {
    get {return _storage._clusterID}
    set {_uniqueStorage()._clusterID = newValue}
  }

  /// Cluster this server is associated with
  public var clusterName: String {
    get {return _storage._clusterName}
    set {_uniqueStorage()._clusterName = newValue}
  }

  /// Tenant this server is associated with
  public var tenantID: String {
    get {return _storage._tenantID}
    set {_uniqueStorage()._tenantID = newValue}
  }

  /// Tenant this server is associated with
  public var tenantName: String {
    get {return _storage._tenantName}
    set {_uniqueStorage()._tenantName = newValue}
  }

  /// Most recent health report from the server. This field may be blank if the server has never
  /// communicated with the cloud.
  public var health: Sensory_Api_Common_ServerHealthResponse {
    get {return _storage._health ?? Sensory_Api_Common_ServerHealthResponse()}
    set {_uniqueStorage()._health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  public var hasHealth: Bool {return _storage._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  public mutating func clearHealth() {_uniqueStorage()._health = nil}

  /// System metrics
  public var system: Sensory_Api_Common_SystemSummary {
    get {return _storage._system ?? Sensory_Api_Common_SystemSummary()}
    set {_uniqueStorage()._system = newValue}
  }
  /// Returns true if `system` has been explicitly set.
  public var hasSystem: Bool {return _storage._system != nil}
  /// Clears the value of `system`. Subsequent reads from it will return its default value.
  public mutating func clearSystem() {_uniqueStorage()._system = nil}

  /// Created timestamp
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Last updated timestamp
  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  /// Last heard from timestamp. This field may be 0 if the server has never
  /// communicated with the cloud.
  public var lastHeardFrom: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastHeardFrom ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastHeardFrom = newValue}
  }
  /// Returns true if `lastHeardFrom` has been explicitly set.
  public var hasLastHeardFrom: Bool {return _storage._lastHeardFrom != nil}
  /// Clears the value of `lastHeardFrom`. Subsequent reads from it will return its default value.
  public mutating func clearLastHeardFrom() {_uniqueStorage()._lastHeardFrom = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sensory.api.v1.management"

extension Sensory_Api_V1_Management_Void: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOID_VALUE"),
  ]
}

extension Sensory_Api_V1_Management_DeviceEnrollmentSecurityLevels: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "SECRET_KEY"),
    2: .same(proto: "SIGNED_TOKEN"),
  ]
}

extension Sensory_Api_V1_Management_ServerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerConfigRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_ServerConfigRequest, rhs: Sensory_Api_V1_Management_ServerConfigRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_ServerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tenant"),
    2: .same(proto: "cluster"),
    3: .same(proto: "featureFlags"),
    4: .same(proto: "prometheus"),
    5: .same(proto: "dataPersistence"),
    6: .same(proto: "oauthTokenIssuer"),
    7: .same(proto: "grpcPort"),
    8: .same(proto: "webGrpcPort"),
    9: .same(proto: "tritonHost"),
    10: .same(proto: "databaseURL"),
    11: .same(proto: "deviceEnrollmentConfig"),
  ]

  fileprivate class _StorageClass {
    var _tenant: Sensory_Api_V1_Management_TenantResponse? = nil
    var _cluster: Sensory_Api_V1_Management_ClusterResponse? = nil
    var _featureFlags: [Int32] = []
    var _prometheus: Sensory_Api_V1_Management_PrometheusConfig? = nil
    var _dataPersistence: Sensory_Api_V1_Management_DataPersistenceConfig? = nil
    var _oauthTokenIssuer: String = String()
    var _grpcPort: String = String()
    var _webGrpcPort: String = String()
    var _tritonHost: String = String()
    var _databaseURL: String = String()
    var _deviceEnrollmentConfig: Sensory_Api_V1_Management_DeviceEnrollmentConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tenant = source._tenant
      _cluster = source._cluster
      _featureFlags = source._featureFlags
      _prometheus = source._prometheus
      _dataPersistence = source._dataPersistence
      _oauthTokenIssuer = source._oauthTokenIssuer
      _grpcPort = source._grpcPort
      _webGrpcPort = source._webGrpcPort
      _tritonHost = source._tritonHost
      _databaseURL = source._databaseURL
      _deviceEnrollmentConfig = source._deviceEnrollmentConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tenant) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cluster) }()
        case 3: try { try decoder.decodeRepeatedInt32Field(value: &_storage._featureFlags) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._prometheus) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._dataPersistence) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._oauthTokenIssuer) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._grpcPort) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._webGrpcPort) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._tritonHost) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._databaseURL) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._deviceEnrollmentConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tenant {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._cluster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._featureFlags.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._featureFlags, fieldNumber: 3)
      }
      if let v = _storage._prometheus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._dataPersistence {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._oauthTokenIssuer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._oauthTokenIssuer, fieldNumber: 6)
      }
      if !_storage._grpcPort.isEmpty {
        try visitor.visitSingularStringField(value: _storage._grpcPort, fieldNumber: 7)
      }
      if !_storage._webGrpcPort.isEmpty {
        try visitor.visitSingularStringField(value: _storage._webGrpcPort, fieldNumber: 8)
      }
      if !_storage._tritonHost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tritonHost, fieldNumber: 9)
      }
      if !_storage._databaseURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._databaseURL, fieldNumber: 10)
      }
      if let v = _storage._deviceEnrollmentConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_ServerConfig, rhs: Sensory_Api_V1_Management_ServerConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tenant != rhs_storage._tenant {return false}
        if _storage._cluster != rhs_storage._cluster {return false}
        if _storage._featureFlags != rhs_storage._featureFlags {return false}
        if _storage._prometheus != rhs_storage._prometheus {return false}
        if _storage._dataPersistence != rhs_storage._dataPersistence {return false}
        if _storage._oauthTokenIssuer != rhs_storage._oauthTokenIssuer {return false}
        if _storage._grpcPort != rhs_storage._grpcPort {return false}
        if _storage._webGrpcPort != rhs_storage._webGrpcPort {return false}
        if _storage._tritonHost != rhs_storage._tritonHost {return false}
        if _storage._databaseURL != rhs_storage._databaseURL {return false}
        if _storage._deviceEnrollmentConfig != rhs_storage._deviceEnrollmentConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_PrometheusConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrometheusConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_PrometheusConfig, rhs: Sensory_Api_V1_Management_PrometheusConfig) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_DataPersistenceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataPersistenceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "none"),
    2: .same(proto: "localConfig"),
    3: .same(proto: "s3Config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sensory_Api_V1_Management_Void?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.persistenceType != nil {try decoder.handleConflictingOneOf()}
          self.persistenceType = .none(v)
        }
      }()
      case 2: try {
        var v: Sensory_Api_V1_Management_DataPersistenceLocalConfig?
        var hadOneofValue = false
        if let current = self.persistenceType {
          hadOneofValue = true
          if case .localConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.persistenceType = .localConfig(v)
        }
      }()
      case 3: try {
        var v: Sensory_Api_V1_Management_DataPersistenceS3Config?
        var hadOneofValue = false
        if let current = self.persistenceType {
          hadOneofValue = true
          if case .s3Config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.persistenceType = .s3Config(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.persistenceType {
    case .none?: try {
      guard case .none(let v)? = self.persistenceType else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .localConfig?: try {
      guard case .localConfig(let v)? = self.persistenceType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .s3Config?: try {
      guard case .s3Config(let v)? = self.persistenceType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_DataPersistenceConfig, rhs: Sensory_Api_V1_Management_DataPersistenceConfig) -> Bool {
    if lhs.persistenceType != rhs.persistenceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_ServerHeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerHeartbeatRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "health"),
    3: .same(proto: "system"),
    4: .same(proto: "users"),
    5: .same(proto: "devices"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _health: Sensory_Api_Common_ServerHealthResponse? = nil
    var _system: Sensory_Api_Common_SystemSummary? = nil
    var _users: Sensory_Api_V1_Management_UserSummary? = nil
    var _devices: Sensory_Api_V1_Management_DeviceSummary? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _health = source._health
      _system = source._system
      _users = source._users
      _devices = source._devices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._health) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._system) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._users) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._devices) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._health {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._system {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._users {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._devices {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_ServerHeartbeatRequest, rhs: Sensory_Api_V1_Management_ServerHeartbeatRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._system != rhs_storage._system {return false}
        if _storage._users != rhs_storage._users {return false}
        if _storage._devices != rhs_storage._devices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_HeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeartbeatResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_HeartbeatResponse, rhs: Sensory_Api_V1_Management_HeartbeatResponse) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_UserSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_UserSummary, rhs: Sensory_Api_V1_Management_UserSummary) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_DeviceSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_DeviceSummary, rhs: Sensory_Api_V1_Management_DeviceSummary) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_DeviceEnrollmentConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceEnrollmentConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "securityLevel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.securityLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.securityLevel != .none {
      try visitor.visitSingularEnumField(value: self.securityLevel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_DeviceEnrollmentConfig, rhs: Sensory_Api_V1_Management_DeviceEnrollmentConfig) -> Bool {
    if lhs.securityLevel != rhs.securityLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_DataPersistenceLocalConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataPersistenceLocalConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localPath.isEmpty {
      try visitor.visitSingularStringField(value: self.localPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_DataPersistenceLocalConfig, rhs: Sensory_Api_V1_Management_DataPersistenceLocalConfig) -> Bool {
    if lhs.localPath != rhs.localPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_DataPersistenceS3Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataPersistenceS3Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "s3AccessKey"),
    2: .same(proto: "s3SecretKey"),
    3: .same(proto: "s3Region"),
    4: .same(proto: "s3Bucket"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.s3AccessKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.s3SecretKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.s3Region) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.s3Bucket) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.s3AccessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.s3AccessKey, fieldNumber: 1)
    }
    if !self.s3SecretKey.isEmpty {
      try visitor.visitSingularStringField(value: self.s3SecretKey, fieldNumber: 2)
    }
    if !self.s3Region.isEmpty {
      try visitor.visitSingularStringField(value: self.s3Region, fieldNumber: 3)
    }
    if !self.s3Bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.s3Bucket, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_DataPersistenceS3Config, rhs: Sensory_Api_V1_Management_DataPersistenceS3Config) -> Bool {
    if lhs.s3AccessKey != rhs.s3AccessKey {return false}
    if lhs.s3SecretKey != rhs.s3SecretKey {return false}
    if lhs.s3Region != rhs.s3Region {return false}
    if lhs.s3Bucket != rhs.s3Bucket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_ServerListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tenantId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tenantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tenantID.isEmpty {
      try visitor.visitSingularStringField(value: self.tenantID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_ServerListRequest, rhs: Sensory_Api_V1_Management_ServerListRequest) -> Bool {
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_ServerListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "servers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.servers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.servers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.servers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_ServerListResponse, rhs: Sensory_Api_V1_Management_ServerListResponse) -> Bool {
    if lhs.servers != rhs.servers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sensory_Api_V1_Management_ServerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "isRemote"),
    4: .same(proto: "clusterId"),
    5: .same(proto: "clusterName"),
    6: .same(proto: "tenantId"),
    7: .same(proto: "tenantName"),
    8: .same(proto: "health"),
    9: .same(proto: "system"),
    10: .same(proto: "createdAt"),
    11: .same(proto: "updatedAt"),
    12: .same(proto: "lastHeardFrom"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _isRemote: Bool = false
    var _clusterID: String = String()
    var _clusterName: String = String()
    var _tenantID: String = String()
    var _tenantName: String = String()
    var _health: Sensory_Api_Common_ServerHealthResponse? = nil
    var _system: Sensory_Api_Common_SystemSummary? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastHeardFrom: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _isRemote = source._isRemote
      _clusterID = source._clusterID
      _clusterName = source._clusterName
      _tenantID = source._tenantID
      _tenantName = source._tenantName
      _health = source._health
      _system = source._system
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _lastHeardFrom = source._lastHeardFrom
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isRemote) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._clusterID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._clusterName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._tenantID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._tenantName) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._health) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._system) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._lastHeardFrom) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._isRemote != false {
        try visitor.visitSingularBoolField(value: _storage._isRemote, fieldNumber: 3)
      }
      if !_storage._clusterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterID, fieldNumber: 4)
      }
      if !_storage._clusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterName, fieldNumber: 5)
      }
      if !_storage._tenantID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tenantID, fieldNumber: 6)
      }
      if !_storage._tenantName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tenantName, fieldNumber: 7)
      }
      if let v = _storage._health {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._system {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._lastHeardFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sensory_Api_V1_Management_ServerResponse, rhs: Sensory_Api_V1_Management_ServerResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._isRemote != rhs_storage._isRemote {return false}
        if _storage._clusterID != rhs_storage._clusterID {return false}
        if _storage._clusterName != rhs_storage._clusterName {return false}
        if _storage._tenantID != rhs_storage._tenantID {return false}
        if _storage._tenantName != rhs_storage._tenantName {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._system != rhs_storage._system {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._lastHeardFrom != rhs_storage._lastHeardFrom {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
